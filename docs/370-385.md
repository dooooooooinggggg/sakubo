## 攻撃を検知する
検知のためにみるべきポイントは
- ログファイル
- ネットワークパケット
- プログラムのメモリ内

## システムデーモン
デーモンとは制御ターミナルから切り離され、バックグラウンドで稼働するプログラム

Linuxにおいては、SSHサービスを提供したり、システムのログを管理し続けるというようなタスクを休むことなく実行し続けるもの

デーモンはシグナルを用いて瀬御するのが一般的

### シグナルについて
シグナルによってプロセス間通信が可能になる。プロセスがシグナルを受信すると、プロセス制御はOSの割り込みによって中断され、シグナルハンドラが呼び出される

シグナルの分かりやすい例として、Ctrl + Cによるプログラム終了コマンドがある。これは実際に無限ループしているプログラムにおいても、割り込みをかけて結果的に強制終了できる。

*tinywebd.cを覗いてみる*
```
if(daemon(1, 0) == -1) // バックグラウンドのデーモンプロセスをフォークする。
      fatal("デーモンプロセスのフォークに失敗しました。"); 
```
daemonの起動。ここで子プロセスを生成し、親は終了
```
signal(SIGTERM, handle_shutdown);
signal(SIGINT, handle_shutdown);
```
上記のコードは、`SIGTERM`, `SIGINT`というシグナルを待ち受けて、handle_shutdownハンドラを呼び出す記述である。これによって、シグナルの待ち受け状態を作ることができる
```
while(1) { // 受け付けループ
  sin_size = sizeof(struct sockaddr_in); 
  new_sockfd = accept(sockfd, (struct sockaddr *)&client_addr, &sin_size); 
  if(new_sockfd == -1) 
      fatal("コネクションの受け付けに失敗しました。"); 

  handle_connection(new_sockfd, &client_addr, logfd); 
}
```
あとはループを回しながら待ち受けの状態を維持する。実際のコネクション処理は`handle_connection`に任せられる。

## デーモンに対する攻撃
デーモンに対する攻撃は通常のプログラムに対する攻撃よりも難しい。デーモンは親からフォークされて子プロセスとして続行されるが、親プロセスは終了してしまう。そのため、GDBで脆弱性を発見するためには工夫が必要となる。

GDBに親プロセスではなく、子プロセスを追いかけるように指示をする。

実際に攻撃を行うとき、コネクションを任せられている`handle_connection`について動きを見ていく。
`handle_connection`内には500バイトのrequestがあり、その戻り値を上書きすることができればバッファオーバーフローを引き起こすことができる。(rf: 0x330)


Tips: 上記の例においても、シェルコードのサイズは可変であり、シェルコードの先頭アドレスを予測することは困難となる。そのような場合には、NOPスレッドを埋めることで、ある程度大雑把な戻りアドレスの指定を許容することができる。レジスタに実際に攻撃を成功させるためには、このような一定の予期できない繰り返し処理が必要な場面が考えられるので、簡単なシェルコードを自作するなどして、ツール化していくのが良いとされる。
